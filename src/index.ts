/**
 * @file This plugin is to access classification image data from different sources. Make sure that
 * the data is conform to expectation.
 */

import {
  ArgsType,
  parseAnnotation,
  DataAccessType,
  CocoDataset,
  ImageDataLoader,
  ImageLabel,
  convertPascal2CocoFileOutput,
  shuffle,
  ImageSample
} from '@pipcook/pipcook-core';
import glob from 'glob-promise';
import * as path from 'path';
import * as fs from 'fs-extra';

interface DataPair {
  annotation: string;
  image: string;
  label: ImageLabel;
}

class DataLoader extends ImageDataLoader {
  dataPairs!: DataPair[];
  constructor(dataPairs: DataPair[]) {
    super();
    shuffle(dataPairs);
    this.dataPairs = dataPairs;
  }

  async len(): Promise<number> {
    return this.dataPairs.length;
  }

  async getItem(id: number): Promise<ImageSample> {
    return {
      data: this.dataPairs[id].image,
      label: this.dataPairs[id].label
    };
  }

  async setItem(id: number, sample: ImageSample): Promise<void> {
    this.dataPairs[id].image = sample.data;
    this.dataPairs[id].label = sample.label;
  }
}

/**
 * merge all possible values of labels. Get the map between label and numeric value
 * @param dataPath
 */
const getLabelMap = async (dataPath: string) => {
  const labelSet = new Set<string>();
  const trainFileNames: string[] = await glob(path.join(dataPath, 'train', '*.xml'));
  for (let j = 0; j < trainFileNames.length; j++) {
    const fileName = trainFileNames[j];
    const imageData: any = await parseAnnotation(fileName);
    imageData.annotation.object.forEach((object: any) => {
      labelSet.add(object.name[0]);
    });
  }

  const labelArray = Array.from(labelSet);
  const labelMap: {[key: string]: number} = {};
  labelArray.forEach((label: any, index: number) => {
    labelMap[label] = index;
  });
  return labelMap;
};

const getValidPair = async (dataPath: string, labelMap: Record<string, number>) => {
  const cocoJson: any = {
    info: {
      "description": "dataset generated by pipcook",
      "url": "http:\/\/mscoco.org",
      "version": "1.0", "year":2014,
      "contributor": "Microsoft COCO group",
      "date_created": "2015-01-27 09:11:52.357475"
    },
    images: [],
    licenses: [
      {
        "url": "http:\/\/creativecommons.org\/licenses\/by-nc-sa\/2.0\/",
        "id": 1,
        "name": "Attribution-NonCommercial-ShareAlike License"
      }
    ],
    annotations: [],
    categories: []
  };
  const annotationPaths = await glob(path.join(dataPath, '*.xml'));
  const pairs: DataPair[] = [];
  for (let i = 0; i < annotationPaths.length; i++) {
    const fileName = annotationPaths[i];
    const imageData: any = await parseAnnotation(fileName);
    const imageName = imageData.annotation.filename[0];
    const imageItem: any = {
      license: 1,
      file_name: imageName,
      coco_url: 'default',
      id: i + 1
    };
    if (imageData.annotation.size && imageData.annotation.size[0]) {
      imageItem.width = parseInt(imageData.annotation.size[0].width[0]);
      imageItem.height = parseInt(imageData.annotation.size[0].height[0]);
    }
    if (fs.existsSync(path.join(dataPath, imageName))) {
      cocoJson.images.push(imageItem);
      imageData.annotation.object.forEach((object: any) => {
        if (typeof labelMap[object.name[0]] === 'undefined') {
          throw new TypeError(`category: ${object.name[0]} is not match with train/*.xml (from ${fileName})`);
        }
        const label: ImageLabel = {
          name: object.name[0],
          categoryId: labelMap[object.name[0]]
        };
        const category = cocoJson.categories.find((e: any) => e.name === object.name[0]);
        let id;
        if (category) {
          id = category.id;
        } else {
          id = labelMap[object.name[0]];
          cocoJson.categories.push({
            id: labelMap[object.name[0]],
            name: object.name[0],
            supercategory: object.name[0]
          });
        }
        const cocoItem: any = {
          id: cocoJson.annotations.length + 1,
          image_id: i + 1,
          category_id: id,
          iscrowd: Number((object.iscrowd && object.iscrowd[0])) || 0
        };
        if (object.segmentation && object.segmentation[0]) {
          if (object.segmentation[0].counts) {
            cocoItem.segmentation = {
              counts: object.segmentation[0].counts[0],
              size: [
                Number(object.segmentation[0].size[0]),
                Number(object.segmentation[0].size[1])
              ]
            };
          } else if (object.segmentation[0].polygon) {
            cocoItem.segmentation = object.segmentation[0].polygon[0];
          }
        }
  
        if (object.bndbox && object.bndbox[0]) {
          const width = parseInt(object.bndbox[0].xmax[0]) - parseInt(object.bndbox[0].xmin[0]);
          const height = parseInt(object.bndbox[0].ymax[0]) - parseInt(object.bndbox[0].ymin[0]);
          cocoItem.bbox = [ parseInt(object.bndbox[0].xmin[0]), parseInt(object.bndbox[0].ymin[0]), width, height ];
          cocoItem.area = Number(width * height);
        }
        cocoJson.annotations.push(cocoItem);
        if (object.bndbox) {
          label.bndbox = {
            xmin: Number(object.bndbox[0].xmin[0]),
            ymin: Number(object.bndbox[0].ymin[0]),
            xmax: Number(object.bndbox[0].xmax[0]),
            ymax: Number(object.bndbox[0].ymax[0])
          };
        }
        if (object.segmentation) {
          label.segmentation = object.segmentation[0];
        }
        pairs.push({
          annotation: fileName,
          image: path.join(dataPath, imageName),
          label
        });
      });
    }
  }
  await fs.outputJSON(path.join(dataPath, 'annotation.json'), cocoJson);
  return pairs;
};

/**
 * The plugin used to access data from different sources. It will detect all possible values of labels and
 * merge them into numeric expressions.
 */
const cocoDataAccess: DataAccessType = async (args: ArgsType): Promise<CocoDataset> => {
  const {
    dataDir
  } = args;

  const labelMap = await getLabelMap(dataDir);
  const labelArray = Object.keys(labelMap).sort((k1, k2) => labelMap[k1] - labelMap[k2]);

  const trainPair = await getValidPair(path.join(dataDir, 'train'), labelMap);
  const validationPair = await getValidPair(path.join(dataDir, 'validation'), labelMap);
  const testPair = await getValidPair(path.join(dataDir, 'test'), labelMap);

  const isBitMask = trainPair[0].label.segmentation?.hasOwnProperty('counts');

  const trainLoader = new DataLoader(trainPair);
  const validationLoader = new DataLoader(validationPair);
  const testLoader = new DataLoader(testPair);

  const result: CocoDataset = {
    metadata: {
      labelMap,
      isBitMask,
      labelArray
    },
    dataStatistics: [],
    validationResult: {
      result: true
    },
    trainAnnotationPath: path.join(dataDir, 'train', 'annotation.json'),
    validationAnnotationPath: path.join(dataDir, 'validation', 'annotation.json'),
    testAnnotationPath: path.join(dataDir, 'test', 'annotation.json')
  };

  if (trainPair.length > 0) {
    result.trainLoader = trainLoader;
  }
  if (validationPair.length > 0) {
    result.validationLoader = validationLoader;
  }
  if (testPair.length > 0) {
    result.testLoader = testLoader;
  }

  return result;
};

export default cocoDataAccess;
